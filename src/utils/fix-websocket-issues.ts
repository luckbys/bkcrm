// üîß CORRE√á√ïES PARA PROBLEMAS DO WEBSOCKET
// Execute: fixWebSocketIssues() no console

interface WebSocketFix {
  issue: string;
  status: 'FIXED' | 'FAILED' | 'SKIPPED';
  details: string;
}

export const fixWebSocketIssues = async (): Promise<void> => {
  console.log('üîß [FIX] Iniciando corre√ß√µes do sistema WebSocket...');
  console.log('='.repeat(60));
  
  const fixes: WebSocketFix[] = [];
  
  // 1. CORRE√á√ÉO: URL de conex√£o WebSocket
  console.log('1Ô∏è‚É£ Corrigindo URL de conex√£o WebSocket...');
  try {
    const chatStore = (window as any).useChatStore?.getState?.();
    
    if (chatStore) {
      // For√ßar reconex√£o com URL correta
      const currentHostname = window.location.hostname;
      const expectedUrl = currentHostname === 'localhost' || currentHostname === '127.0.0.1' 
        ? 'http://localhost:4000' 
        : 'https://websocket.bkcrm.devsible.com.br';
      
      console.log(`üîó [FIX] URL esperada: ${expectedUrl}`);
      console.log(`üîó [FIX] Hostname atual: ${currentHostname}`);
      
      // Desconectar e reconectar
      if (chatStore.socket) {
        chatStore.disconnect();
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      chatStore.init();
      
      fixes.push({
        issue: 'URL WebSocket Connection',
        status: 'FIXED',
        details: `Reconectado para ${expectedUrl}`
      });
      
      console.log('‚úÖ [FIX] URL de conex√£o corrigida');
    } else {
      fixes.push({
        issue: 'URL WebSocket Connection',
        status: 'FAILED',
        details: 'chatStore n√£o encontrado'
      });
      console.log('‚ùå [FIX] chatStore n√£o encontrado');
    }
  } catch (error) {
    fixes.push({
      issue: 'URL WebSocket Connection',
      status: 'FAILED',
      details: `Erro: ${error}`
    });
    console.log('‚ùå [FIX] Erro ao corrigir URL:', error);
  }
  
  // 2. CORRE√á√ÉO: Eventos de carregamento de mensagens
  console.log('2Ô∏è‚É£ Corrigindo eventos de carregamento...');
  try {
    const chatStore = (window as any).useChatStore?.getState?.();
    
    if (chatStore?.socket) {
      // Remover listeners antigos e adicionar novos
      chatStore.socket.off('new-message');
      chatStore.socket.off('messages-loaded');
      
      // Listener melhorado para novas mensagens
      chatStore.socket.on('new-message', (data: any) => {
        console.log('üì® [FIX] Nova mensagem recebida (listener corrigido):', {
          id: data.id,
          ticketId: data.ticket_id || data.ticketId,
          content: data.content?.substring(0, 50) + '...',
          sender: data.sender || (data.sender_id ? 'agent' : 'client'),
          isInternal: data.is_internal
        });
        
        // For√ßar atualiza√ß√£o do estado
        const currentState = chatStore;
        const ticketId = data.ticket_id || data.ticketId;
        
        if (ticketId && currentState.messages) {
          const currentMessages = currentState.messages[ticketId] || [];
          
          // Verificar duplica√ß√£o
          const exists = currentMessages.some((msg: any) => 
            msg.id === data.id || 
            (msg.content === data.content && 
             Math.abs(new Date(msg.timestamp).getTime() - new Date(data.created_at || Date.now()).getTime()) < 5000)
          );
          
          if (!exists) {
            // Trigger evento customizado para for√ßar re-render
            window.dispatchEvent(new CustomEvent('websocket-message-received', { 
              detail: { ticketId, message: data } 
            }));
          }
        }
      });
      
      // Listener melhorado para mensagens carregadas
      chatStore.socket.on('messages-loaded', (data: any) => {
        console.log('üì• [FIX] Mensagens carregadas (listener corrigido):', {
          ticketId: data.ticketId,
          count: data.messages?.length || 0
        });
        
        // Trigger evento customizado
        window.dispatchEvent(new CustomEvent('websocket-messages-loaded', { 
          detail: data 
        }));
      });
      
      fixes.push({
        issue: 'Message Loading Events',
        status: 'FIXED',
        details: 'Listeners de eventos atualizados'
      });
      
      console.log('‚úÖ [FIX] Eventos de carregamento corrigidos');
    } else {
      fixes.push({
        issue: 'Message Loading Events',
        status: 'SKIPPED',
        details: 'Socket n√£o conectado'
      });
      console.log('‚ö†Ô∏è [FIX] Socket n√£o conectado, eventos n√£o corrigidos');
    }
  } catch (error) {
    fixes.push({
      issue: 'Message Loading Events',
      status: 'FAILED',
      details: `Erro: ${error}`
    });
    console.log('‚ùå [FIX] Erro ao corrigir eventos:', error);
  }
  
  // 3. CORRE√á√ÉO: Broadcast de mensagens no servidor
  console.log('3Ô∏è‚É£ Testando broadcast do servidor...');
  try {
    const isLocal = window.location.hostname === 'localhost';
    const testUrl = isLocal 
      ? 'http://localhost:4000/webhook/evolution'
      : 'https://websocket.bkcrm.devsible.com.br/webhook/evolution';
    
    // Enviar mensagem de teste para verificar broadcast
    const testPayload = {
      event: 'MESSAGES_UPSERT',
      instance: 'atendimento-ao-cliente-suporte',
      data: {
        key: {
          id: 'BROADCAST_TEST_' + Date.now(),
          remoteJid: '5511999887766@s.whatsapp.net',
          fromMe: false
        },
        message: {
          conversation: 'üîß Teste de broadcast - ' + new Date().toLocaleTimeString()
        },
        messageTimestamp: Date.now(),
        pushName: 'Teste Broadcast'
      }
    };
    
    const response = await fetch(testUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(testPayload)
    });
    
    const result = await response.json();
    
    if (result.websocket) {
      fixes.push({
        issue: 'Server Broadcast',
        status: 'FIXED',
        details: 'Broadcast funcionando corretamente'
      });
      console.log('‚úÖ [FIX] Broadcast do servidor OK');
    } else {
      fixes.push({
        issue: 'Server Broadcast',
        status: 'FAILED',
        details: 'Broadcast n√£o est√° funcionando'
      });
      console.log('‚ùå [FIX] Broadcast do servidor com problemas');
    }
  } catch (error) {
    fixes.push({
      issue: 'Server Broadcast',
      status: 'FAILED',
      details: `Erro: ${error}`
    });
    console.log('‚ùå [FIX] Erro ao testar broadcast:', error);
  }
  
  // 4. CORRE√á√ÉO: Join de tickets
  console.log('4Ô∏è‚É£ Corrigindo join de tickets...');
  try {
    const chatStore = (window as any).useChatStore?.getState?.();
    
    if (chatStore?.socket && chatStore.isConnected) {
      // Criar fun√ß√£o melhorada de join
      (window as any).fixedJoinTicket = (ticketId: string) => {
        console.log(`üîó [FIX] Join melhorado para ticket: ${ticketId}`);
        
        // Primeiro fazer join
        chatStore.socket.emit('join-ticket', { 
          ticketId, 
          userId: '00000000-0000-0000-0000-000000000001' // UUID do sistema
        });
        
        // Depois solicitar mensagens
        setTimeout(() => {
          console.log(`üì• [FIX] Solicitando mensagens para: ${ticketId}`);
          chatStore.socket.emit('request-messages', { 
            ticketId, 
            limit: 50 
          });
        }, 500);
        
        // Aguardar resposta
        return new Promise((resolve) => {
          const timeout = setTimeout(() => {
            console.log('‚è∞ [FIX] Timeout ao carregar mensagens');
            resolve(false);
          }, 10000);
          
          const handleLoaded = (data: any) => {
            if (data.ticketId === ticketId) {
              clearTimeout(timeout);
              chatStore.socket.off('messages-loaded', handleLoaded);
              console.log(`‚úÖ [FIX] Mensagens carregadas para: ${ticketId}`);
              resolve(true);
            }
          };
          
          chatStore.socket.on('messages-loaded', handleLoaded);
        });
      };
      
      fixes.push({
        issue: 'Ticket Join Process',
        status: 'FIXED',
        details: 'Fun√ß√£o fixedJoinTicket() criada'
      });
      
      console.log('‚úÖ [FIX] Join de tickets corrigido - use fixedJoinTicket(ticketId)');
    } else {
      fixes.push({
        issue: 'Ticket Join Process',
        status: 'SKIPPED',
        details: 'Socket n√£o conectado'
      });
      console.log('‚ö†Ô∏è [FIX] Socket n√£o conectado para corrigir join');
    }
  } catch (error) {
    fixes.push({
      issue: 'Ticket Join Process',
      status: 'FAILED',
      details: `Erro: ${error}`
    });
    console.log('‚ùå [FIX] Erro ao corrigir join:', error);
  }
  
  // 5. CORRE√á√ÉO: Fun√ß√£o de envio melhorada
  console.log('5Ô∏è‚É£ Criando fun√ß√£o de envio melhorada...');
  try {
    (window as any).fixedSendMessage = async (ticketId: string, content: string, isInternal = false) => {
      console.log(`üì§ [FIX] Envio melhorado:`, { ticketId, content: content.substring(0, 50), isInternal });
      
      const chatStore = (window as any).useChatStore?.getState?.();
      
      if (!chatStore?.socket || !chatStore.isConnected) {
        console.log('‚ùå [FIX] Socket n√£o conectado para envio');
        return false;
      }
      
      try {
        // Enviar via WebSocket
        chatStore.socket.emit('send-message', {
          ticketId,
          content: content.trim(),
          isInternal,
          userId: '00000000-0000-0000-0000-000000000001',
          senderName: 'Atendente'
        });
        
        console.log('‚úÖ [FIX] Mensagem enviada via WebSocket');
        
        // Se n√£o for interna, tentar Evolution API
        if (!isInternal) {
          try {
            const evolutionPayload = {
              phone: '5512981022013', // N√∫mero de teste
              text: content,
              instance: 'atendimento-ao-cliente-suporte'
            };
            
            const response = await fetch('http://localhost:4000/webhook/send-message', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(evolutionPayload)
            });
            
            if (response.ok) {
              console.log('‚úÖ [FIX] Mensagem enviada via Evolution API');
            } else {
              console.log('‚ö†Ô∏è [FIX] Falha no envio via Evolution API');
            }
          } catch (evolutionError) {
            console.log('‚ö†Ô∏è [FIX] Erro Evolution API:', evolutionError);
          }
        }
        
        return true;
      } catch (error) {
        console.log('‚ùå [FIX] Erro no envio:', error);
        return false;
      }
    };
    
    fixes.push({
      issue: 'Message Sending',
      status: 'FIXED',
      details: 'Fun√ß√£o fixedSendMessage() criada'
    });
    
    console.log('‚úÖ [FIX] Fun√ß√£o de envio melhorada criada - use fixedSendMessage(ticketId, content, isInternal)');
  } catch (error) {
    fixes.push({
      issue: 'Message Sending',
      status: 'FAILED',
      details: `Erro: ${error}`
    });
    console.log('‚ùå [FIX] Erro ao criar fun√ß√£o de envio:', error);
  }
  
  // 6. RESUMO DAS CORRE√á√ïES
  console.log('='.repeat(60));
  console.log('üìä RESUMO DAS CORRE√á√ïES:');
  console.log('='.repeat(60));
  
  const fixed = fixes.filter(f => f.status === 'FIXED');
  const failed = fixes.filter(f => f.status === 'FAILED');
  const skipped = fixes.filter(f => f.status === 'SKIPPED');
  
  console.log(`‚úÖ Corrigidos: ${fixed.length}`);
  console.log(`‚ùå Falharam: ${failed.length}`);
  console.log(`‚ö†Ô∏è Ignorados: ${skipped.length}`);
  
  if (fixed.length > 0) {
    console.log('\n‚úÖ CORRE√á√ïES APLICADAS:');
    fixed.forEach(fix => {
      console.log(`‚úÖ ${fix.issue}: ${fix.details}`);
    });
  }
  
  if (failed.length > 0) {
    console.log('\n‚ùå CORRE√á√ïES FALHARAM:');
    failed.forEach(fix => {
      console.log(`‚ùå ${fix.issue}: ${fix.details}`);
    });
  }
  
  // 7. FUN√á√ïES DISPON√çVEIS
  console.log('\nüîß FUN√á√ïES DE CORRE√á√ÉO DISPON√çVEIS:');
  console.log('üìä diagnoseMessagesIssue() - Diagn√≥stico completo');
  console.log('üîß fixWebSocketIssues() - Aplicar todas as corre√ß√µes');
  console.log('üîó fixedJoinTicket(ticketId) - Join melhorado de ticket');
  console.log('üì§ fixedSendMessage(ticketId, content, isInternal) - Envio melhorado');
  console.log('üëÅÔ∏è monitorMessages() - Monitorar mensagens em tempo real');
  
  // Expor resultados
  (window as any).lastFixResults = fixes;
  
  return;
};

// Fun√ß√£o para testar o fluxo completo
export const testCompleteFlow = async (ticketId: string = 'test-ticket-' + Date.now()): Promise<void> => {
  console.log('üß™ [TEST] Testando fluxo completo de mensagens...');
  
  try {
    // 1. Join no ticket
    console.log('1Ô∏è‚É£ Fazendo join no ticket...');
    const joinResult = await (window as any).fixedJoinTicket?.(ticketId);
    
    if (joinResult) {
      console.log('‚úÖ Join realizado com sucesso');
      
      // 2. Enviar mensagem
      console.log('2Ô∏è‚É£ Enviando mensagem de teste...');
      const sendResult = await (window as any).fixedSendMessage?.(ticketId, 'Mensagem de teste do fluxo completo', false);
      
      if (sendResult) {
        console.log('‚úÖ Mensagem enviada com sucesso');
        console.log('üéâ Fluxo completo funcionando!');
      } else {
        console.log('‚ùå Falha no envio da mensagem');
      }
    } else {
      console.log('‚ùå Falha no join do ticket');
    }
  } catch (error) {
    console.error('‚ùå Erro no teste do fluxo:', error);
  }
};

// Expor fun√ß√µes globalmente
(window as any).fixWebSocketIssues = fixWebSocketIssues;
(window as any).testCompleteFlow = testCompleteFlow;

console.log('üîß [FIX] Sistema de corre√ß√µes WebSocket carregado');
console.log('üîß Execute: fixWebSocketIssues() para aplicar todas as corre√ß√µes');
console.log('üß™ Execute: testCompleteFlow() para testar o fluxo completo'); 