/**
 * üîß CORRE√á√ÉO: Duplica√ß√£o de Tickets no Webhook Evolution API
 * 
 * Problema identificado: Webhook est√° criando m√∫ltiplos tickets para o mesmo cliente/telefone
 * devido a condi√ß√µes de busca inadequadas ou processamento concorrente.
 */

import { supabase } from '../lib/supabase';

interface TicketData {
  id: string;
  phone_number: string;
  status: string;
  created_at: string;
  updated_at: string;
  customer_id?: string;
  subject?: string;
  description?: string;
}

interface DuplicationAnalysis {
  totalTickets: number;
  uniquePhones: number;
  duplicatedPhones: string[];
  duplicateGroups: Record<string, TicketData[]>;
  recommendations: string[];
}

/**
 * üîç Analisar duplica√ß√£o de tickets
 */
const analyzeDuplication = async (): Promise<DuplicationAnalysis> => {
  console.log('üîç [AN√ÅLISE] Iniciando an√°lise de duplica√ß√£o de tickets...');
  
  try {
    // Buscar todos os tickets com n√∫meros de telefone
    const { data: tickets, error } = await supabase
      .from('tickets')
      .select('id, phone_number, status, created_at, updated_at, customer_id, subject, description')
      .not('phone_number', 'is', null)
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('‚ùå Erro ao buscar tickets:', error);
      throw error;
    }
    
    console.log(`üìä Total de tickets encontrados: ${tickets?.length || 0}`);
    
    // Agrupar por n√∫mero normalizado
    const phoneGroups: Record<string, TicketData[]> = {};
    const seenPhones = new Set<string>();
    
    tickets?.forEach(ticket => {
      const normalizedPhone = normalizePhone(ticket.phone_number);
      if (normalizedPhone) {
        if (!phoneGroups[normalizedPhone]) {
          phoneGroups[normalizedPhone] = [];
        }
        phoneGroups[normalizedPhone].push(ticket);
        seenPhones.add(normalizedPhone);
      }
    });
    
    // Identificar duplica√ß√µes
    const duplicateGroups: Record<string, TicketData[]> = {};
    const duplicatedPhones: string[] = [];
    
    Object.entries(phoneGroups).forEach(([phone, ticketGroup]) => {
      if (ticketGroup.length > 1) {
        duplicatedPhones.push(phone);
        duplicateGroups[phone] = ticketGroup;
      }
    });
    
    const recommendations: string[] = [];
    
    if (duplicatedPhones.length > 0) {
      recommendations.push(`Encontrados ${duplicatedPhones.length} n√∫meros com duplica√ß√µes`);
      recommendations.push('Execute fixDuplication() para consolidar tickets');
      recommendations.push('Considere implementar valida√ß√£o preventiva no webhook');
    } else {
      recommendations.push('Nenhuma duplica√ß√£o encontrada');
      recommendations.push('Sistema est√° funcionando corretamente');
    }
    
    const analysis: DuplicationAnalysis = {
      totalTickets: tickets?.length || 0,
      uniquePhones: seenPhones.size,
      duplicatedPhones,
      duplicateGroups,
      recommendations
    };
    
    // Log da an√°lise
    console.log('\nüìä RESULTADO DA AN√ÅLISE:');
    console.table({
      'Total de Tickets': analysis.totalTickets,
      'N√∫meros √önicos': analysis.uniquePhones,
      'N√∫meros Duplicados': analysis.duplicatedPhones.length,
      'Taxa de Duplica√ß√£o': `${((analysis.duplicatedPhones.length / analysis.uniquePhones) * 100).toFixed(1)}%`
    });
    
    if (analysis.duplicatedPhones.length > 0) {
      console.log('\nüîç DUPLICA√á√ïES ENCONTRADAS:');
      Object.entries(analysis.duplicateGroups).forEach(([phone, tickets]) => {
        console.log(`\nüìû ${phone} (${tickets.length} tickets):`);
        tickets.forEach((ticket, index) => {
          console.log(`  ${index + 1}. ${ticket.id} - ${ticket.status} - ${new Date(ticket.created_at).toLocaleString()}`);
        });
      });
    }
    
    return analysis;
    
  } catch (error) {
    console.error('‚ùå Erro na an√°lise:', error);
    throw error;
  }
};

/**
 * üîß Corrigir duplica√ß√£o mantendo o ticket mais recente ativo
 */
const fixDuplication = async (simulate: boolean = true): Promise<void> => {
  console.log(`üîß [FIX] ${simulate ? 'SIMULANDO' : 'EXECUTANDO'} corre√ß√£o de duplica√ß√µes...`);
  
  try {
    // Primeiro fazer an√°lise
    const analysis = await analyzeDuplication();
    
    if (analysis.duplicatedPhones.length === 0) {
      console.log('‚úÖ Nenhuma duplica√ß√£o encontrada para corrigir');
      return;
    }
    
    console.log(`\nüîß Processando ${analysis.duplicatedPhones.length} n√∫meros duplicados...`);
    
    let totalFixed = 0;
    let totalMerged = 0;
    
    for (const [phone, tickets] of Object.entries(analysis.duplicateGroups)) {
      console.log(`\nüìû Processando ${phone} (${tickets.length} tickets)...`);
      
      // Ordenar por data de cria√ß√£o (mais recente primeiro)
      tickets.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
      
      const mainTicket = tickets[0]; // Mais recente
      const duplicateTickets = tickets.slice(1); // Outros
      
      console.log(`  ‚úÖ Mantendo: ${mainTicket.id} (${new Date(mainTicket.created_at).toLocaleString()})`);
      
      // Processar duplicatas
      for (const duplicateTicket of duplicateTickets) {
        console.log(`  üîÑ ${simulate ? 'SIMULARIA' : 'Processando'}: ${duplicateTicket.id}`);
        
        if (!simulate) {
          // 1. Mover mensagens do ticket duplicado para o principal
          const { error: moveError } = await supabase
            .from('messages')
            .update({ ticket_id: mainTicket.id })
            .eq('ticket_id', duplicateTicket.id);
          
          if (moveError) {
            console.error(`  ‚ùå Erro ao mover mensagens de ${duplicateTicket.id}:`, moveError);
            continue;
          }
          
          // 2. Atualizar status do ticket duplicado para fechado
          const { error: updateError } = await supabase
            .from('tickets')
            .update({ 
              status: 'closed',
              description: `Ticket consolidado em ${mainTicket.id} - ${duplicateTicket.description || ''}`,
              updated_at: new Date().toISOString()
            })
            .eq('id', duplicateTicket.id);
          
          if (updateError) {
            console.error(`  ‚ùå Erro ao fechar ticket ${duplicateTicket.id}:`, updateError);
            continue;
          }
          
          console.log(`  ‚úÖ Ticket ${duplicateTicket.id} consolidado em ${mainTicket.id}`);
        }
        
        totalMerged++;
      }
      
      totalFixed++;
    }
    
    console.log(`\n‚úÖ CORRE√á√ÉO ${simulate ? 'SIMULADA' : 'CONCLU√çDA'}:`);
    console.table({
      'N√∫meros Processados': totalFixed,
      'Tickets Consolidados': totalMerged,
      'Modo': simulate ? 'Simula√ß√£o' : 'Execu√ß√£o Real'
    });
    
    if (simulate) {
      console.log('\nüí° Para executar a corre√ß√£o real, use: fixDuplication(false)');
    } else {
      console.log('\nüéâ Duplica√ß√µes corrigidas com sucesso!');
      
      // An√°lise final
      console.log('\nüîç Executando an√°lise final...');
      await analyzeDuplication();
    }
    
  } catch (error) {
    console.error('‚ùå Erro na corre√ß√£o:', error);
  }
};

/**
 * üì± Normalizar n√∫mero de telefone
 */
const normalizePhone = (phone: string): string => {
  if (!phone) return '';
  
  // Remover caracteres especiais e espa√ßos
  let normalized = phone.replace(/[^\d]/g, '');
  
  // Remover c√≥digo do pa√≠s se presente (55 para Brasil)
  if (normalized.startsWith('55') && normalized.length > 11) {
    normalized = normalized.substring(2);
  }
  
  // Remover 9 extra se presente no celular
  if (normalized.length === 11 && normalized.charAt(2) === '9') {
    normalized = normalized.substring(0, 2) + normalized.substring(3);
  }
  
  return normalized;
};

/**
 * üîç Verificar webhook Evolution API para prevenir duplica√ß√£o futura
 */
const analyzeWebhookBehavior = async (): Promise<void> => {
  console.log('üï∑Ô∏è [WEBHOOK] Analisando comportamento do webhook...');
  
  try {
    // Buscar tickets criados nas √∫ltimas 24h
    const last24h = new Date();
    last24h.setHours(last24h.getHours() - 24);
    
    const { data: recentTickets, error } = await supabase
      .from('tickets')
      .select('id, phone_number, created_at, status')
      .gte('created_at', last24h.toISOString())
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('‚ùå Erro ao buscar tickets recentes:', error);
      return;
    }
    
    console.log(`üìä Tickets criados nas √∫ltimas 24h: ${recentTickets?.length || 0}`);
    
    if (!recentTickets || recentTickets.length === 0) {
      console.log('‚ÑπÔ∏è Nenhum ticket recente para analisar');
      return;
    }
    
    // Analisar padr√µes suspeitos
    const phoneFrequency: Record<string, number> = {};
    const timeGaps: number[] = [];
    
    recentTickets.forEach((ticket, index) => {
      const normalizedPhone = normalizePhone(ticket.phone_number);
      phoneFrequency[normalizedPhone] = (phoneFrequency[normalizedPhone] || 0) + 1;
      
      // Calcular gap entre tickets consecutivos
      if (index > 0) {
        const currentTime = new Date(ticket.created_at).getTime();
        const prevTime = new Date(recentTickets[index - 1].created_at).getTime();
        const gap = Math.abs(currentTime - prevTime) / 1000; // em segundos
        timeGaps.push(gap);
      }
    });
    
    // Identificar poss√≠veis problemas
    const suspiciousPhones = Object.entries(phoneFrequency)
      .filter(([phone, count]) => count > 1)
      .map(([phone, count]) => ({ phone, count }));
    
    const avgGap = timeGaps.length > 0 ? timeGaps.reduce((a, b) => a + b, 0) / timeGaps.length : 0;
    const minGap = Math.min(...timeGaps);
    
    console.log('\nüìä AN√ÅLISE DO WEBHOOK:');
    console.table({
      'Tickets nas 24h': recentTickets.length,
      'N√∫meros √∫nicos': Object.keys(phoneFrequency).length,
      'N√∫meros duplicados': suspiciousPhones.length,
      'Gap m√©dio (s)': Math.round(avgGap),
      'Gap m√≠nimo (s)': Math.round(minGap)
    });
    
    if (suspiciousPhones.length > 0) {
      console.log('\n‚ö†Ô∏è N√öMEROS SUSPEITOS (m√∫ltiplos tickets):');
      suspiciousPhones.forEach(({ phone, count }) => {
        console.log(`üìû ${phone}: ${count} tickets`);
      });
    }
    
    if (minGap < 60) {
      console.log(`\n‚ö†Ô∏è Gap muito pequeno detectado: ${Math.round(minGap)}s`);
      console.log('üí° Considere implementar debounce no webhook');
    }
    
  } catch (error) {
    console.error('‚ùå Erro na an√°lise do webhook:', error);
  }
};

// üåê Exportar para uso global
declare global {
  interface Window {
    fixWebhookDuplication: {
      analyze: () => Promise<DuplicationAnalysis>;
      fix: (simulate: boolean) => Promise<void>;
      webhookAnalysis: () => Promise<void>;
      implementPrevention: () => void;
      normalizePhone: (phone: string) => string;
      fixAll: (simulate: boolean) => Promise<void>;
    };
  }
}

if (typeof window !== 'undefined') {
  window.fixWebhookDuplication = {
    analyze: analyzeDuplication,
    fix: fixDuplication,
    webhookAnalysis: analyzeWebhookBehavior,
    implementPrevention: () => {
      console.log('üîß [PREVEN√á√ÉO] Implementando preven√ß√£o de duplica√ß√£o...');
      
      const preventionCode = `
// üõ°Ô∏è PREVEN√á√ÉO DE DUPLICA√á√ÉO NO WEBHOOK
async function preventDuplication(phoneNumber, webhookData) {
  const normalizedPhone = "${normalizePhone.toString()}";
  const phone = normalizedPhone(phoneNumber);
  
  // Verificar se j√° existe ticket ativo para este n√∫mero
  const { data: existingTickets } = await supabase
    .from('tickets')
    .select('id, status, created_at')
    .eq('phone_number', phone)
    .in('status', ['open', 'pending', 'in_progress'])
    .order('created_at', { ascending: false })
    .limit(1);
  
  if (existingTickets && existingTickets.length > 0) {
    const existingTicket = existingTickets[0];
    console.log('üîÑ Ticket existente encontrado:', existingTicket.id);
    
    // Adicionar nova mensagem ao ticket existente
    await supabase
      .from('messages')
      .insert([{
        ticket_id: existingTicket.id,
        content: webhookData.message || 'Nova intera√ß√£o via webhook',
        sender_name: webhookData.sender || 'Cliente',
        is_internal: false,
        type: 'message'
      }]);
    
    return { action: 'updated', ticketId: existingTicket.id };
  }
  
  // Criar novo ticket apenas se n√£o existir
  return { action: 'create_new' };
}`;
      
      console.log('üìã C√≥digo de preven√ß√£o gerado:');
      console.log(preventionCode);
      
      console.log('\nüí° Para implementar:');
      console.log('1. Adicione esta fun√ß√£o ao seu webhook handler');
      console.log('2. Chame preventDuplication() antes de criar novos tickets');
      console.log('3. Teste com analyzeWebhookBehavior() regularmente');
    },
    normalizePhone,
    fixAll: async (simulate: boolean) => {
      console.log('üîß [FIX-ALL] Iniciando corre√ß√£o completa de duplica√ß√µes...');
      await analyzeDuplication();
      await fixDuplication(simulate);
      await analyzeWebhookBehavior();
    }
  };

  console.log(`
üîß CORRE√á√ÉO DE DUPLICA√á√ÉO DE TICKETS ATIVADA

üìã Comandos dispon√≠veis:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üîç AN√ÅLISE:
fixWebhookDuplication.analyze()              // Analisar √∫ltimos 7 dias
fixWebhookDuplication.webhookAnalysis()       // Analisar webhook atual

üîß CORRE√á√ÉO:
fixWebhookDuplication.fix(true)               // Simular corre√ß√£o
fixWebhookDuplication.fix(false)              // Corrigir de fato

üîß PREVEN√á√ÉO:
fixWebhookDuplication.implementPrevention()     // C√≥digo de preven√ß√£o

üîß CORRE√á√ÉO COMPLETA:
fixWebhookDuplication.fixAll(true)             // Simular corre√ß√£o completa
fixWebhookDuplication.fixAll(false)            // Corrigir tudo (CUIDADO!)

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  `);
}

export {
  analyzeDuplication,
  fixDuplication,
  analyzeWebhookBehavior
}; 