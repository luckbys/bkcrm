// üß™ Script de Teste Avan√ßado - UnifiedChatModal UX Features
// Execu√ß√£o: testUnifiedChatUX() no console do navegador

interface TestResult {
  feature: string;
  status: 'success' | 'error' | 'warning';
  message: string;
  duration?: number;
}

class UnifiedChatUXTester {
  private results: TestResult[] = [];
  private startTime: number = 0;

  constructor() {
    console.log('üß™ Iniciando Teste de UX do UnifiedChatModal...');
    console.log('üìã Funcionalidades a serem testadas:');
    console.log('   1. Sistema Drag & Drop');
    console.log('   2. Templates de Resposta');
    console.log('   3. Auto-Save de Rascunhos');
    console.log('   4. Indicadores Visuais');
    console.log('   5. Hist√≥rico de A√ß√µes');
    console.log('   6. Prefer√™ncias Avan√ßadas');
    console.log('   7. Sistema de Notifica√ß√µes');
    console.log('');
  }

  private log(feature: string, status: 'success' | 'error' | 'warning', message: string, duration?: number) {
    const icons = { success: '‚úÖ', error: '‚ùå', warning: '‚ö†Ô∏è' };
    const colors = { success: 'color: green', error: 'color: red', warning: 'color: orange' };
    
    console.log(`%c${icons[status]} ${feature}: ${message}`, colors[status]);
    if (duration) {
      console.log(`   ‚è±Ô∏è Tempo: ${duration}ms`);
    }
    
    this.results.push({ feature, status, message, duration });
  }

  // üß™ Teste 1: Sistema Drag & Drop
  async testDragDropSystem(): Promise<void> {
    console.log('\nüß™ [TESTE 1] Sistema Drag & Drop');
    this.startTime = performance.now();

    try {
      // Verificar se elementos existem
      const chatArea = document.querySelector('[data-testid="chat-area"]') || 
                      document.querySelector('.flex.flex-col.flex-1.min-h-0.relative');
      
      if (!chatArea) {
        this.log('Drag & Drop', 'warning', '√Årea de chat n√£o encontrada - modal pode estar fechado');
        return;
      }

      // Simular evento de drag over
      const dragEvent = new DragEvent('dragover', {
        bubbles: true,
        cancelable: true,
        dataTransfer: new DataTransfer()
      });

      chatArea.dispatchEvent(dragEvent);
      
      // Verificar se overlay aparece
      setTimeout(() => {
        const overlay = document.querySelector('.absolute.inset-0.z-50.bg-blue-500\\/20');
        if (overlay) {
          this.log('Drag & Drop', 'success', 'Overlay visual funcionando corretamente');
        } else {
          this.log('Drag & Drop', 'warning', 'Overlay n√£o encontrado - verificar implementa√ß√£o');
        }
      }, 100);

      const duration = performance.now() - this.startTime;
      this.log('Drag & Drop', 'success', 'Sistema testado com sucesso', duration);

    } catch (error) {
      this.log('Drag & Drop', 'error', `Erro no teste: ${error}`);
    }
  }

  // üß™ Teste 2: Templates de Resposta
  async testTemplateSystem(): Promise<void> {
    console.log('\nüß™ [TESTE 2] Templates de Resposta');
    this.startTime = performance.now();

    try {
      // Procurar bot√£o de templates
      const templateButton = Array.from(document.querySelectorAll('button')).find(btn => 
        btn.textContent?.includes('Templates') || btn.querySelector('[data-lucide="zap"]')
      );

      if (!templateButton) {
        this.log('Templates', 'warning', 'Bot√£o de templates n√£o encontrado - modal pode estar fechado');
        return;
      }

      // Simular clique no bot√£o
      templateButton.click();
      
      setTimeout(() => {
        // Verificar se popover aparece
        const popover = document.querySelector('.absolute.bottom-full.mb-2.left-0.z-50.bg-white.border');
        if (popover) {
          this.log('Templates', 'success', 'Popover de templates exibido corretamente');
          
          // Testar sele√ß√£o de template
          const templateItem = popover.querySelector('button');
          if (templateItem) {
            templateItem.click();
            this.log('Templates', 'success', 'Template aplicado com sucesso');
          }
        } else {
          this.log('Templates', 'warning', 'Popover n√£o encontrado');
        }
      }, 100);

      const duration = performance.now() - this.startTime;
      this.log('Templates', 'success', 'Sistema testado', duration);

    } catch (error) {
      this.log('Templates', 'error', `Erro no teste: ${error}`);
    }
  }

  // üß™ Teste 3: Auto-Save de Rascunhos
  async testAutoSaveSystem(): Promise<void> {
    console.log('\nüß™ [TESTE 3] Auto-Save de Rascunhos');
    this.startTime = performance.now();

    try {
      // Procurar textarea de mensagem
      const textarea = document.querySelector('textarea') as HTMLTextAreaElement;
      
      if (!textarea) {
        this.log('Auto-Save', 'warning', 'Textarea n√£o encontrada - modal pode estar fechado');
        return;
      }

      // Simular digita√ß√£o
      const testMessage = 'Esta √© uma mensagem de teste para auto-save funcionalidade';
      
      // Simular eventos de input
      textarea.value = testMessage;
      textarea.dispatchEvent(new Event('input', { bubbles: true }));
      textarea.dispatchEvent(new Event('change', { bubbles: true }));

      // Verificar localStorage ap√≥s delay
      setTimeout(() => {
        const draftKeys = Object.keys(localStorage).filter(key => key.startsWith('draft_'));
        if (draftKeys.length > 0) {
          this.log('Auto-Save', 'success', `Rascunho salvo no localStorage (${draftKeys.length} tickets)`);
          
          // Verificar indicador visual
          const draftIndicator = Array.from(document.querySelectorAll('span')).find(span =>
            span.textContent?.includes('Rascunho salvo')
          );
          
          if (draftIndicator) {
            this.log('Auto-Save', 'success', 'Indicador visual de rascunho salvo funcionando');
          }
        } else {
          this.log('Auto-Save', 'warning', 'Nenhum rascunho encontrado no localStorage');
        }
      }, 1000);

      const duration = performance.now() - this.startTime;
      this.log('Auto-Save', 'success', 'Sistema testado', duration);

    } catch (error) {
      this.log('Auto-Save', 'error', `Erro no teste: ${error}`);
    }
  }

  // üß™ Teste 4: Indicadores Visuais
  async testVisualIndicators(): Promise<void> {
    console.log('\nüß™ [TESTE 4] Indicadores Visuais');
    this.startTime = performance.now();

    try {
      // Testar contador de caracteres
      const charCounter = Array.from(document.querySelectorAll('span')).find(span =>
        span.textContent?.includes('/2000')
      );

      if (charCounter) {
        this.log('Indicadores', 'success', 'Contador de caracteres encontrado');
        
        // Verificar cores baseadas no conte√∫do
        const className = charCounter.className;
        if (className.includes('text-red-500') || className.includes('text-yellow-500') || className.includes('text-gray-400')) {
          this.log('Indicadores', 'success', 'Cores din√¢micas do contador funcionando');
        }
      } else {
        this.log('Indicadores', 'warning', 'Contador de caracteres n√£o encontrado');
      }

      // Testar status de conex√£o
      const connectionBadge = document.querySelector('[class*="text-green-500"], [class*="text-red-500"]');
      if (connectionBadge) {
        this.log('Indicadores', 'success', 'Indicador de conex√£o encontrado');
      }

      const duration = performance.now() - this.startTime;
      this.log('Indicadores', 'success', 'Sistema testado', duration);

    } catch (error) {
      this.log('Indicadores', 'error', `Erro no teste: ${error}`);
    }
  }

  // üß™ Teste 5: Hist√≥rico de A√ß√µes
  async testActionHistory(): Promise<void> {
    console.log('\nüß™ [TESTE 5] Hist√≥rico de A√ß√µes');
    this.startTime = performance.now();

    try {
      // Procurar se√ß√£o de hist√≥rico na sidebar
      const historySection = Array.from(document.querySelectorAll('h4')).find(h4 =>
        h4.textContent?.includes('Hist√≥rico')
      );

      if (historySection) {
        this.log('Hist√≥rico', 'success', 'Se√ß√£o de hist√≥rico encontrada na sidebar');
        
        // Verificar se h√° itens de hist√≥rico
        const historyItems = historySection.parentElement?.querySelectorAll('.text-xs.p-2.bg-gray-50');
        if (historyItems && historyItems.length > 0) {
          this.log('Hist√≥rico', 'success', `${historyItems.length} itens de hist√≥rico encontrados`);
        } else {
          this.log('Hist√≥rico', 'warning', 'Nenhum item de hist√≥rico encontrado');
        }
      } else {
        this.log('Hist√≥rico', 'warning', 'Se√ß√£o de hist√≥rico n√£o encontrada - sidebar pode estar fechada');
      }

      const duration = performance.now() - this.startTime;
      this.log('Hist√≥rico', 'success', 'Sistema testado', duration);

    } catch (error) {
      this.log('Hist√≥rico', 'error', `Erro no teste: ${error}`);
    }
  }

  // üß™ Teste 6: Prefer√™ncias Avan√ßadas
  async testAdvancedPreferences(): Promise<void> {
    console.log('\nüß™ [TESTE 6] Prefer√™ncias Avan√ßadas');
    this.startTime = performance.now();

    try {
      // Procurar se√ß√£o de prefer√™ncias
      const preferencesSection = Array.from(document.querySelectorAll('h4')).find(h4 =>
        h4.textContent?.includes('Prefer√™ncias')
      );

      if (preferencesSection) {
        this.log('Prefer√™ncias', 'success', 'Se√ß√£o de prefer√™ncias encontrada');
        
        // Verificar toggles
        const toggles = preferencesSection.parentElement?.querySelectorAll('button[class*="h-6 w-10 p-0"]');
        if (toggles && toggles.length > 0) {
          this.log('Prefer√™ncias', 'success', `${toggles.length} toggles de prefer√™ncias encontrados`);
          
          // Testar clique em toggle
          const firstToggle = toggles[0] as HTMLButtonElement;
          firstToggle.click();
          this.log('Prefer√™ncias', 'success', 'Toggle testado com sucesso');
        }
      } else {
        this.log('Prefer√™ncias', 'warning', 'Se√ß√£o de prefer√™ncias n√£o encontrada');
      }

      const duration = performance.now() - this.startTime;
      this.log('Prefer√™ncias', 'success', 'Sistema testado', duration);

    } catch (error) {
      this.log('Prefer√™ncias', 'error', `Erro no teste: ${error}`);
    }
  }

  // üß™ Teste 7: Sistema de Notifica√ß√µes
  async testNotificationSystem(): Promise<void> {
    console.log('\nüß™ [TESTE 7] Sistema de Notifica√ß√µes');
    this.startTime = performance.now();

    try {
      // Verificar se container de notifica√ß√µes existe
      const notificationContainer = document.querySelector('[data-testid="notification-container"]') ||
                                   document.querySelector('.fixed');

      if (notificationContainer) {
        this.log('Notifica√ß√µes', 'success', 'Container de notifica√ß√µes encontrado');
      } else {
        this.log('Notifica√ß√µes', 'warning', 'Container de notifica√ß√µes n√£o encontrado');
      }

      // Simular cria√ß√£o de notifica√ß√£o via eventos
      try {
        // Verificar se h√° notifica√ß√µes ativas
        const activeNotifications = document.querySelectorAll('[data-testid="notification"], [role="alert"]');
        if (activeNotifications.length > 0) {
          this.log('Notifica√ß√µes', 'success', `${activeNotifications.length} notifica√ß√µes ativas encontradas`);
        }
      } catch (e) {
        this.log('Notifica√ß√µes', 'warning', 'N√£o foi poss√≠vel verificar notifica√ß√µes ativas');
      }

      const duration = performance.now() - this.startTime;
      this.log('Notifica√ß√µes', 'success', 'Sistema testado', duration);

    } catch (error) {
      this.log('Notifica√ß√µes', 'error', `Erro no teste: ${error}`);
    }
  }

  // üìä Relat√≥rio Final
  generateReport(): void {
    console.log('\nüìä RELAT√ìRIO FINAL DE TESTES UX');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    const successCount = this.results.filter(r => r.status === 'success').length;
    const warningCount = this.results.filter(r => r.status === 'warning').length;
    const errorCount = this.results.filter(r => r.status === 'error').length;
    
    console.log(`‚úÖ Sucessos: ${successCount}`);
    console.log(`‚ö†Ô∏è Avisos: ${warningCount}`);
    console.log(`‚ùå Erros: ${errorCount}`);
    console.log('');
    
    // Detalhamento por feature
    const features = [...new Set(this.results.map(r => r.feature))];
    features.forEach(feature => {
      const featureResults = this.results.filter(r => r.feature === feature);
      const success = featureResults.filter(r => r.status === 'success').length;
      const total = featureResults.length;
      const percentage = Math.round((success / total) * 100);
      
      console.log(`üìã ${feature}: ${success}/${total} (${percentage}%)`);
    });
    
    console.log('');
    console.log('üéØ RECOMENDA√á√ïES:');
    
    if (warningCount > 0) {
      console.log('‚ö†Ô∏è Alguns elementos podem n√£o estar vis√≠veis devido ao modal estar fechado');
      console.log('   üí° Abra o UnifiedChatModal antes de executar os testes');
    }
    
    if (successCount >= 10) {
      console.log('üèÜ Excelente! Todas as principais funcionalidades UX est√£o funcionando');
    } else if (successCount >= 7) {
      console.log('üëç Bom! A maioria das funcionalidades est√° funcionando corretamente');
    } else {
      console.log('üîß Algumas funcionalidades precisam de verifica√ß√£o adicional');
    }
    
    console.log('');
    console.log('üìà M√âTRICAS DE PERFORMANCE:');
    const avgDuration = this.results
      .filter(r => r.duration)
      .reduce((sum, r) => sum + (r.duration || 0), 0) / this.results.filter(r => r.duration).length;
    
    if (avgDuration) {
      console.log(`‚è±Ô∏è Tempo m√©dio de resposta: ${Math.round(avgDuration)}ms`);
      console.log(`üöÄ Performance: ${avgDuration < 100 ? 'Excelente' : avgDuration < 200 ? 'Boa' : 'Satisfat√≥ria'}`);
    }
  }

  // üß™ Executar Todos os Testes
  async runAllTests(): Promise<void> {
    console.log('üöÄ Iniciando bateria completa de testes...\n');
    
    await this.testDragDropSystem();
    await new Promise(resolve => setTimeout(resolve, 500));
    
    await this.testTemplateSystem();
    await new Promise(resolve => setTimeout(resolve, 500));
    
    await this.testAutoSaveSystem();
    await new Promise(resolve => setTimeout(resolve, 1500)); // Mais tempo para auto-save
    
    await this.testVisualIndicators();
    await new Promise(resolve => setTimeout(resolve, 500));
    
    await this.testActionHistory();
    await new Promise(resolve => setTimeout(resolve, 500));
    
    await this.testAdvancedPreferences();
    await new Promise(resolve => setTimeout(resolve, 500));
    
    await this.testNotificationSystem();
    await new Promise(resolve => setTimeout(resolve, 500));
    
    this.generateReport();
  }
}

// üåü Fun√ß√£o Principal para Execu√ß√£o
async function testUnifiedChatUX(): Promise<void> {
  console.clear();
  console.log('üé® TESTE DE UX - UnifiedChatModal');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('');
  
  const tester = new UnifiedChatUXTester();
  await tester.runAllTests();
  
  console.log('');
  console.log('üí° INSTRU√á√ïES PARA TESTE MANUAL:');
  console.log('1. Abra um ticket no sistema');
  console.log('2. Clique para abrir o UnifiedChatModal');
  console.log('3. Execute novamente: testUnifiedChatUX()');
  console.log('4. Teste manualmente: arrastar arquivos, usar templates, etc.');
  console.log('');
  console.log('üîß FUN√á√ïES INDIVIDUAIS DISPON√çVEIS:');
  console.log('- testDragDrop()');
  console.log('- testTemplates()');
  console.log('- testAutoSave()');
  console.log('- testIndicators()');
  console.log('- testHistory()');
  console.log('- testPreferences()');
  console.log('- testNotifications()');
}

// üéØ Fun√ß√µes Individuais para Teste Espec√≠fico
function testDragDrop() { new UnifiedChatUXTester().testDragDropSystem(); }
function testTemplates() { new UnifiedChatUXTester().testTemplateSystem(); }
function testAutoSave() { new UnifiedChatUXTester().testAutoSaveSystem(); }
function testIndicators() { new UnifiedChatUXTester().testVisualIndicators(); }
function testHistory() { new UnifiedChatUXTester().testActionHistory(); }
function testPreferences() { new UnifiedChatUXTester().testAdvancedPreferences(); }
function testNotifications() { new UnifiedChatUXTester().testNotificationSystem(); }

// üìä Fun√ß√£o de Demonstra√ß√£o Autom√°tica
async function demoUnifiedChatUX(): Promise<void> {
  console.log('üé¨ DEMONSTRA√á√ÉO AUTOM√ÅTICA - UnifiedChatModal UX');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('Esta demo simula as intera√ß√µes do usu√°rio...\n');
  
  // Simular abertura do modal
  console.log('1. üñ±Ô∏è Usu√°rio abre o chat modal...');
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Simular uso de template
  console.log('2. ‚ö° Usu√°rio clica em Templates...');
  console.log('   üìù Template "Sauda√ß√£o" aplicado!');
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Simular digita√ß√£o
  console.log('3. ‚å®Ô∏è Usu√°rio digita mensagem...');
  console.log('   üíæ Auto-save ativo!');
  console.log('   üìä Contador: 45/2000 caracteres');
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Simular drag & drop
  console.log('4. üìÇ Usu√°rio arrasta arquivo...');
  console.log('   üéØ Overlay azul aparece');
  console.log('   ‚úÖ Arquivo validado e anexado');
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Simular envio
  console.log('5. üì§ Usu√°rio envia mensagem...');
  console.log('   üîî Notifica√ß√£o: "Mensagem enviada!"');
  console.log('   üìà A√ß√£o adicionada ao hist√≥rico');
  console.log('   üßπ Rascunho removido');
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  console.log('\nüéâ DEMONSTRA√á√ÉO CONCLU√çDA!');
  console.log('üí° Execute testUnifiedChatUX() para testes reais');
}

// Exportar para uso global
declare global {
  interface Window {
    testUnifiedChatUX: () => Promise<void>;
    demoUnifiedChatUX: () => Promise<void>;
    testDragDrop: () => void;
    testTemplates: () => void;
    testAutoSave: () => void;
    testIndicators: () => void;
    testHistory: () => void;
    testPreferences: () => void;
    testNotifications: () => void;
  }
}

// Disponibilizar globalmente
if (typeof window !== 'undefined') {
  window.testUnifiedChatUX = testUnifiedChatUX;
  window.demoUnifiedChatUX = demoUnifiedChatUX;
  window.testDragDrop = testDragDrop;
  window.testTemplates = testTemplates;
  window.testAutoSave = testAutoSave;
  window.testIndicators = testIndicators;
  window.testHistory = testHistory;
  window.testPreferences = testPreferences;
  window.testNotifications = testNotifications;
}

export { testUnifiedChatUX, demoUnifiedChatUX, UnifiedChatUXTester }; 